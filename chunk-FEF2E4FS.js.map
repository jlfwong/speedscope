{
  "version": 3,
  "sources": ["../../package.json", "../../src/lib/utils.ts", "../../src/lib/value-formatters.ts", "../../src/lib/profile.ts", "../../src/lib/file-format-spec.ts", "../../src/lib/file-format.ts"],
  "sourcesContent": ["{\n  \"name\": \"speedscope\",\n  \"version\": \"1.22.1\",\n  \"description\": \"\",\n  \"repository\": \"jlfwong/speedscope\",\n  \"main\": \"index.js\",\n  \"bin\": {\n    \"speedscope\": \"./bin/cli.mjs\"\n  },\n  \"scripts\": {\n    \"deploy\": \"./scripts/deploy.sh\",\n    \"prepack\": \"./scripts/prepack.sh --outdir \\\"$(pwd)/dist/release\\\" --protocol file\",\n    \"prettier\": \"prettier --write 'src/**/*.ts' 'src/**/*.tsx'\",\n    \"lint\": \"eslint 'src/**/*.ts' 'src/**/*.tsx'\",\n    \"jest\": \"./scripts/test-setup.sh && jest --runInBand\",\n    \"coverage\": \"npm run jest -- --coverage\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"test\": \"./scripts/ci.sh\",\n    \"serve\": \"tsx scripts/dev-server.ts\"\n  },\n  \"files\": [\n    \"bin/cli.mjs\",\n    \"dist/release/**\",\n    \"!*.map\"\n  ],\n  \"browserslist\": [\n    \"last 2 Chrome versions\",\n    \"last 2 Firefox versions\"\n  ],\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"@types/jest\": \"22.2.3\",\n    \"@types/jszip\": \"3.1.4\",\n    \"@types/node\": \"14.0.1\",\n    \"@types/pako\": \"1.0.0\",\n    \"@typescript-eslint/eslint-plugin\": \"6.16.0\",\n    \"@typescript-eslint/parser\": \"6.16.0\",\n    \"acorn\": \"7.2.0\",\n    \"aphrodite\": \"2.1.0\",\n    \"esbuild\": \"0.24.2\",\n    \"eslint\": \"8.0.0\",\n    \"eslint-plugin-prettier\": \"5.1.2\",\n    \"eslint-plugin-react-hooks\": \"4.6.0\",\n    \"jest\": \"24.3.0\",\n    \"jsverify\": \"0.8.3\",\n    \"jszip\": \"3.1.5\",\n    \"pako\": \"1.0.6\",\n    \"preact\": \"10.4.1\",\n    \"prettier\": \"3.1.1\",\n    \"protobufjs\": \"6.8.8\",\n    \"source-map\": \"0.6.1\",\n    \"ts-jest\": \"24.3.0\",\n    \"tsx\": \"4.19.2\",\n    \"typescript\": \"5.3.3\",\n    \"typescript-json-schema\": \"0.42.0\",\n    \"uglify-es\": \"3.2.2\",\n    \"uint8array-json-parser\": \"0.0.2\"\n  },\n  \"jest\": {\n    \"transform\": {\n      \"^.+\\\\.tsx?$\": \"ts-jest\"\n    },\n    \"setupFilesAfterEnv\": [\n      \"./src/jest-setup.js\"\n    ],\n    \"testRegex\": \"\\\\.test\\\\.tsx?$\",\n    \"collectCoverageFrom\": [\n      \"**/*.{ts,tsx}\",\n      \"!**/*.d.{ts,tsx}\"\n    ],\n    \"moduleFileExtensions\": [\n      \"ts\",\n      \"tsx\",\n      \"js\",\n      \"jsx\",\n      \"json\"\n    ]\n  },\n  \"dependencies\": {\n    \"open\": \"10.1.0\"\n  }\n}\n", "export function lastOf<T>(ts: T[]): T | null {\n  return ts[ts.length - 1] || null\n}\n\nexport function sortBy<T>(ts: T[], key: (t: T) => number | string): void {\n  function comparator(a: T, b: T) {\n    const keyA = key(a)\n    const keyB = key(b)\n    return keyA < keyB ? -1 : keyA > keyB ? 1 : 0\n  }\n  ts.sort(comparator)\n}\n\nexport function getOrInsert<K, V>(map: Map<K, V>, k: K, fallback: (k: K) => V): V {\n  if (!map.has(k)) map.set(k, fallback(k))\n  return map.get(k)!\n}\n\nexport function getOrElse<K, V>(map: Map<K, V>, k: K, fallback: (k: K) => V): V {\n  if (!map.has(k)) return fallback(k)\n  return map.get(k)!\n}\n\nexport function getOrThrow<K, V>(map: Map<K, V>, k: K): V {\n  if (!map.has(k)) {\n    throw new Error(`Expected key ${k}`)\n  }\n  return map.get(k)!\n}\n\n// Intended to be used to de-duplicate objects based on a key property. This\n// allows value comparisons to be done efficiently and for the returned objects\n// to be used intuitively in Map objects.\n//\n// Example usage:\n//\n// export class Frame {\n//   private constructor(readonly file: string, readonly name: string) {}\n//   get key() { return `${this.file}:${this.name}` }\n//   static getOrInsert(set: KeyedSet<Frame>, file: string, name: string) {\n//     return set.getOrInsert(set, new Frame(file, name))\n//   }\n// }\n//\nexport interface HasKey {\n  readonly key: string | number\n}\nexport class KeyedSet<T extends HasKey> implements Iterable<T> {\n  private map = new Map<string | number, T>()\n\n  getOrInsert(t: T): T {\n    const key = t.key\n    const existing = this.map.get(key)\n    if (existing) return existing\n    this.map.set(key, t)\n    return t\n  }\n  forEach(fn: (t: T) => void) {\n    this.map.forEach(fn)\n  }\n  [Symbol.iterator]() {\n    return this.map.values()\n  }\n}\n\nexport function* itMap<T, U>(it: Iterable<T>, f: (t: T) => U): Iterable<U> {\n  for (let t of it) {\n    yield f(t)\n  }\n}\n\nexport function itForEach<T>(it: Iterable<T>, f: (t: T) => void): void {\n  for (let t of it) {\n    f(t)\n  }\n}\n\nexport function itReduce<T, U>(it: Iterable<T>, f: (a: U, b: T) => U, init: U): U {\n  let accum: U = init\n  for (let t of it) {\n    accum = f(accum, t)\n  }\n  return accum\n}\n\nexport function zeroPad(s: string, width: number) {\n  return new Array(Math.max(width - s.length, 0) + 1).join('0') + s\n}\n\nexport function formatPercent(percent: number) {\n  let formattedPercent = `${percent.toFixed(0)}%`\n  if (percent === 100) formattedPercent = '100%'\n  else if (percent > 99) formattedPercent = '>99%'\n  else if (percent < 0.01) formattedPercent = '<0.01%'\n  else if (percent < 1) formattedPercent = `${percent.toFixed(2)}%`\n  else if (percent < 10) formattedPercent = `${percent.toFixed(1)}%`\n  return formattedPercent\n}\n\nexport function fract(x: number) {\n  return x - Math.floor(x)\n}\n\nexport function triangle(x: number) {\n  return 2.0 * Math.abs(fract(x) - 0.5) - 1.0\n}\n\nexport function findValueBisect(\n  lo: number,\n  hi: number,\n  f: (val: number) => number,\n  target: number,\n  targetRangeSize = 1,\n): [number, number] {\n  console.assert(!isNaN(targetRangeSize) && !isNaN(target))\n  while (true) {\n    if (hi - lo <= targetRangeSize) return [lo, hi]\n    const mid = (hi + lo) / 2\n    const val = f(mid)\n    if (val < target) lo = mid\n    else hi = mid\n  }\n}\n\n// Similar to Array.prototype.findIndex, except uses a binary search.\n//\n// This assumes that the condition transitions exactly once from false to true\n// in the list, e.g. the following is a valid input:\n//\n//  ls        = [a, b, c, d]\n//  ls.map(f) = [false, false, true, true]\n//\n// The following is an invalid input:\n//\n//  ls        = [a, b, c, d]\n//  ls.map(f) = [false, true, false, true]\nexport function findIndexBisect<T>(ls: T[], f: (val: T) => boolean): number {\n  if (ls.length === 0) return -1\n\n  let lo = 0\n  let hi = ls.length - 1\n\n  while (hi !== lo) {\n    const mid = Math.floor((lo + hi) / 2)\n\n    if (f(ls[mid])) {\n      // The desired index is <= mid\n      hi = mid\n    } else {\n      // The desired index is > mid\n      lo = mid + 1\n    }\n  }\n\n  return f(ls[hi]) ? hi : -1\n}\n\nexport function noop(...args: any[]) {}\n\nexport function objectsHaveShallowEquality<T extends object>(a: T, b: T): boolean {\n  for (let key in a) {\n    if (a[key] !== b[key]) return false\n  }\n  for (let key in b) {\n    if (a[key] !== b[key]) return false\n  }\n  return true\n}\n\nexport function memoizeByShallowEquality<T extends object, U>(cb: (t: T) => U): (t: T) => U {\n  let last: {args: T; result: U} | null = null\n  return (args: T) => {\n    let result: U\n    if (last == null) {\n      result = cb(args)\n      last = {args, result}\n      return result\n    } else if (objectsHaveShallowEquality(last.args, args)) {\n      return last.result\n    } else {\n      last.args = args\n      last.result = cb(args)\n      return last.result\n    }\n  }\n}\n\nexport function memoizeByReference<T, U>(cb: (t: T) => U): (t: T) => U {\n  let last: {args: T; result: U} | null = null\n  return (args: T) => {\n    let result: U\n    if (last == null) {\n      result = cb(args)\n      last = {args, result}\n      return result\n    } else if (last.args === args) {\n      return last.result\n    } else {\n      last.args = args\n      last.result = cb(args)\n      return last.result\n    }\n  }\n}\n\nexport function lazyStatic<T>(cb: () => T): () => T {\n  let last: {result: T} | null = null\n  return () => {\n    if (last == null) {\n      last = {result: cb()}\n    }\n    return last.result\n  }\n}\n\nconst base64lookupTable = lazyStatic((): Map<string, number> => {\n  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  const ret = new Map<string, number>()\n  for (let i = 0; i < alphabet.length; i++) {\n    ret.set(alphabet.charAt(i), i)\n  }\n  ret.set('=', -1)\n  return ret\n})\n\n// NOTE: There are probably simpler solutions to this problem, but I have this written already, so\n// until we run into problems with this, let's just use this.\n//\n// See: https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem#The_Unicode_Problem\nexport function decodeBase64(encoded: string): Uint8Array {\n  // Reference: https://www.rfc-editor.org/rfc/rfc4648.txt\n\n  const lookupTable = base64lookupTable()\n\n  // 3 byte groups are represented as sequneces of 4 characters.\n  //\n  // \"The encoding process represents 24-bit groups of input bits as output\n  //  strings of 4 encoded characters.\"\n  //\n  // \"Special processing is performed if fewer than 24 bits are available\n  //  at the end of the data being encoded.  A full encoding quantum is\n  //  always completed at the end of a quantity.  When fewer than 24 input\n  //  bits are available in an input group bits with value zero are added\n  //  (on the right) to form an integral number of 6-bit groups.\"\n\n  if (encoded.length % 4 !== 0) {\n    throw new Error(\n      `Invalid length for base64 encoded string. Expected length % 4 = 0, got length = ${encoded.length}`,\n    )\n  }\n\n  const quartetCount = encoded.length / 4\n  let byteCount: number\n\n  // Special processing is performed if fewer than 24 bits are available\n  // at the end of the data being encoded.  A full encoding quantum is\n  // always completed at the end of a quantity.  When fewer than 24 input\n  // bits are available in an input group, bits with value zero are added\n  // (on the right) to form an integral number of 6-bit groups.  Padding\n  // at the end of the data is performed using the '=' character.  Since\n  // all base 64 input is an integral number of octets, only the following\n  // cases can arise:\n  //\n  // (1) The final quantum of encoding input is an integral multiple of 24\n  //     bits; here, the final unit of encoded output will be an integral\n  //     multiple of 4 characters with no \"=\" padding.\n  //\n  // (2) The final quantum of encoding input is exactly 8 bits; here, the\n  //     final unit of encoded output will be two characters followed by\n  //     two \"=\" padding characters.\n  //\n  // (3) The final quantum of encoding input is exactly 16 bits; here, the\n  //     final unit of encoded output will be three characters followed by\n  //     one \"=\" padding character.\n  if (encoded.length >= 4) {\n    if (encoded.charAt(encoded.length - 1) === '=') {\n      if (encoded.charAt(encoded.length - 2) === '=') {\n        // Case (2)\n        byteCount = quartetCount * 3 - 2\n      } else {\n        // Case (3)\n        byteCount = quartetCount * 3 - 1\n      }\n    } else {\n      // Case (1)\n      byteCount = quartetCount * 3\n    }\n  } else {\n    // Case (1)\n    byteCount = quartetCount * 3\n  }\n\n  const bytes = new Uint8Array(byteCount)\n  let offset = 0\n\n  for (let i = 0; i < quartetCount; i++) {\n    const enc1 = encoded.charAt(i * 4 + 0)\n    const enc2 = encoded.charAt(i * 4 + 1)\n    const enc3 = encoded.charAt(i * 4 + 2)\n    const enc4 = encoded.charAt(i * 4 + 3)\n\n    const sextet1 = lookupTable.get(enc1)\n    const sextet2 = lookupTable.get(enc2)\n    const sextet3 = lookupTable.get(enc3)\n    const sextet4 = lookupTable.get(enc4)\n\n    if (sextet1 == null || sextet2 == null || sextet3 == null || sextet4 == null) {\n      throw new Error(\n        `Invalid quartet at indices ${i * 4} .. ${i * 4 + 3}: ${encoded.substring(\n          i * 4,\n          i * 4 + 3,\n        )}`,\n      )\n    }\n\n    bytes[offset++] = (sextet1 << 2) | (sextet2 >> 4)\n    if (enc3 !== '=') {\n      bytes[offset++] = ((sextet2 & 15) << 4) | (sextet3 >> 2)\n    }\n    if (enc4 !== '=') {\n      bytes[offset++] = ((sextet3 & 7) << 6) | sextet4\n    }\n  }\n\n  if (offset !== byteCount) {\n    throw new Error(`Expected to decode ${byteCount} bytes, but only decoded ${offset})`)\n  }\n\n  return bytes\n}\n", "import {FileFormat} from './file-format-spec'\nimport {zeroPad} from './utils'\n\nexport interface ValueFormatter {\n  unit: FileFormat.ValueUnit\n  format(v: number): string\n}\n\nexport class RawValueFormatter implements ValueFormatter {\n  unit: FileFormat.ValueUnit = 'none'\n  format(v: number) {\n    return v.toLocaleString()\n  }\n}\n\nexport class TimeFormatter implements ValueFormatter {\n  private multiplier: number\n\n  constructor(public unit: 'nanoseconds' | 'microseconds' | 'milliseconds' | 'seconds') {\n    if (unit === 'nanoseconds') this.multiplier = 1e-9\n    else if (unit === 'microseconds') this.multiplier = 1e-6\n    else if (unit === 'milliseconds') this.multiplier = 1e-3\n    else this.multiplier = 1\n  }\n\n  formatUnsigned(v: number) {\n    const s = v * this.multiplier\n\n    if (s / 60 >= 1) {\n      const minutes = Math.floor(s / 60)\n      const seconds = Math.floor(s - minutes * 60).toString()\n      return `${minutes}:${zeroPad(seconds, 2)}`\n    }\n    if (s / 1 >= 1) return `${s.toFixed(2)}s`\n    if (s / 1e-3 >= 1) return `${(s / 1e-3).toFixed(2)}ms`\n    if (s / 1e-6 >= 1) return `${(s / 1e-6).toFixed(2)}\u00B5s`\n    else return `${(s / 1e-9).toFixed(2)}ns`\n  }\n\n  format(v: number) {\n    return `${v < 0 ? '-' : ''}${this.formatUnsigned(Math.abs(v))}`\n  }\n}\n\nexport class ByteFormatter implements ValueFormatter {\n  unit: FileFormat.ValueUnit = 'bytes'\n\n  format(v: number) {\n    if (v < 1024) return `${v.toFixed(0)} B`\n    v /= 1024\n    if (v < 1024) return `${v.toFixed(2)} KB`\n    v /= 1024\n    if (v < 1024) return `${v.toFixed(2)} MB`\n    v /= 1024\n    return `${v.toFixed(2)} GB`\n  }\n}\n", "import {lastOf, KeyedSet} from './utils'\nimport {ValueFormatter, RawValueFormatter} from './value-formatters'\nimport {FileFormat} from './file-format-spec'\n\nexport interface FrameInfo {\n  key: string | number\n\n  // Name of the frame. May be a method name, e.g.\n  // \"ActiveRecord##to_hash\"\n  name: string\n\n  // File path of the code corresponding to this\n  // call stack frame.\n  file?: string\n\n  // Line in the given file where this frame occurs, 1-based.\n  line?: number\n\n  // Column in the file, 1-based.\n  col?: number\n}\n\nexport type SymbolRemapper = (\n  frame: Frame,\n) => {name?: string; file?: string; line?: number; col?: number} | null\n\nexport class HasWeights {\n  private selfWeight = 0\n  private totalWeight = 0\n  getSelfWeight() {\n    return this.selfWeight\n  }\n  getTotalWeight() {\n    return this.totalWeight\n  }\n  addToTotalWeight(delta: number) {\n    this.totalWeight += delta\n  }\n  addToSelfWeight(delta: number) {\n    this.selfWeight += delta\n  }\n\n  overwriteWeightWith(other: HasWeights) {\n    this.selfWeight = other.selfWeight\n    this.totalWeight = other.totalWeight\n  }\n}\n\nexport class Frame extends HasWeights {\n  key: string | number\n\n  // Name of the frame. May be a method name, e.g.\n  // \"ActiveRecord##to_hash\"\n  name: string\n\n  // File path of the code corresponding to this\n  // call stack frame.\n  file?: string\n\n  // Line in the given file where this frame occurs\n  line?: number\n\n  // Column in the file\n  col?: number\n\n  private constructor(info: FrameInfo) {\n    super()\n    this.key = info.key\n    this.name = info.name\n    this.file = info.file\n    this.line = info.line\n    this.col = info.col\n  }\n\n  static root = new Frame({\n    key: '(speedscope root)',\n    name: '(speedscope root)',\n  })\n\n  static getOrInsert(set: KeyedSet<Frame>, info: FrameInfo) {\n    return set.getOrInsert(new Frame(info))\n  }\n}\n\nexport class CallTreeNode extends HasWeights {\n  children: CallTreeNode[] = []\n\n  isRoot() {\n    return this.frame === Frame.root\n  }\n\n  // If a node is \"frozen\", it means it should no longer be mutated.\n  private frozen = false\n  isFrozen() {\n    return this.frozen\n  }\n  freeze() {\n    this.frozen = true\n  }\n\n  constructor(\n    readonly frame: Frame,\n    readonly parent: CallTreeNode | null,\n  ) {\n    super()\n  }\n}\n\nexport interface ProfileGroup {\n  name: string\n  indexToView: number\n  profiles: Profile[]\n}\n\nexport class Profile {\n  protected name: string = ''\n\n  protected totalWeight: number\n\n  protected frames = new KeyedSet<Frame>()\n\n  // Profiles store two call-trees.\n  //\n  // The \"append order\" call tree is the one in which nodes are ordered in\n  // whatever order they were appended to their parent.\n  //\n  // The \"grouped\" call tree is one in which each node has at most one child per\n  // frame. Nodes are ordered in decreasing order of weight\n  protected appendOrderCalltreeRoot = new CallTreeNode(Frame.root, null)\n  protected groupedCalltreeRoot = new CallTreeNode(Frame.root, null)\n\n  public getAppendOrderCalltreeRoot() {\n    return this.appendOrderCalltreeRoot\n  }\n  public getGroupedCalltreeRoot() {\n    return this.groupedCalltreeRoot\n  }\n\n  // List of references to CallTreeNodes at the top of the\n  // stack at the time of the sample.\n  protected samples: CallTreeNode[] = []\n  protected weights: number[] = []\n\n  protected valueFormatter: ValueFormatter = new RawValueFormatter()\n\n  constructor(totalWeight: number = 0) {\n    this.totalWeight = totalWeight\n  }\n\n  shallowClone(): Profile {\n    const profile = new Profile(this.totalWeight)\n    Object.assign(profile, this)\n    return profile\n  }\n\n  formatValue(v: number) {\n    return this.valueFormatter.format(v)\n  }\n  setValueFormatter(f: ValueFormatter) {\n    this.valueFormatter = f\n  }\n  getWeightUnit(): FileFormat.ValueUnit {\n    return this.valueFormatter.unit\n  }\n\n  getName() {\n    return this.name\n  }\n  setName(name: string) {\n    this.name = name\n  }\n\n  getTotalWeight() {\n    return this.totalWeight\n  }\n\n  private totalNonIdleWeight: number | null = null\n  getTotalNonIdleWeight() {\n    if (this.totalNonIdleWeight === null) {\n      this.totalNonIdleWeight = this.groupedCalltreeRoot.children.reduce(\n        (n, c) => n + c.getTotalWeight(),\n        0,\n      )\n    }\n    return this.totalNonIdleWeight\n  }\n\n  // This is private because it should only be called in the ProfileBuilder\n  // classes. Once a Profile instance has been constructed, it should be treated\n  // as immutable.\n  protected sortGroupedCallTree() {\n    function visit(node: CallTreeNode) {\n      node.children.sort((a, b) => -(a.getTotalWeight() - b.getTotalWeight()))\n      node.children.forEach(visit)\n    }\n    visit(this.groupedCalltreeRoot)\n  }\n\n  forEachCallGrouped(\n    openFrame: (node: CallTreeNode, value: number) => void,\n    closeFrame: (node: CallTreeNode, value: number) => void,\n  ) {\n    function visit(node: CallTreeNode, start: number) {\n      if (node.frame !== Frame.root) {\n        openFrame(node, start)\n      }\n\n      let childTime = 0\n\n      node.children.forEach(function (child) {\n        visit(child, start + childTime)\n        childTime += child.getTotalWeight()\n      })\n\n      if (node.frame !== Frame.root) {\n        closeFrame(node, start + node.getTotalWeight())\n      }\n    }\n    visit(this.groupedCalltreeRoot, 0)\n  }\n\n  forEachCall(\n    openFrame: (node: CallTreeNode, value: number) => void,\n    closeFrame: (node: CallTreeNode, value: number) => void,\n  ) {\n    let prevStack: CallTreeNode[] = []\n    let value = 0\n\n    let sampleIndex = 0\n    for (let stackTop of this.samples) {\n      // Find lowest common ancestor of the current stack and the previous one\n      let lca: CallTreeNode | null = null\n\n      // This is O(n^2), but n should be relatively small here (stack height),\n      // so hopefully this isn't much of a problem\n      for (\n        lca = stackTop;\n        lca && lca.frame != Frame.root && prevStack.indexOf(lca) === -1;\n        lca = lca.parent\n      ) {}\n\n      // Close frames that are no longer open\n      while (prevStack.length > 0 && lastOf(prevStack) != lca) {\n        const node = prevStack.pop()!\n        closeFrame(node, value)\n      }\n\n      // Open frames that are now becoming open\n      const toOpen: CallTreeNode[] = []\n      for (\n        let node: CallTreeNode | null = stackTop;\n        node && node.frame != Frame.root && node != lca;\n        node = node.parent\n      ) {\n        toOpen.push(node)\n      }\n      toOpen.reverse()\n\n      for (let node of toOpen) {\n        openFrame(node, value)\n      }\n\n      prevStack = prevStack.concat(toOpen)\n      value += this.weights[sampleIndex++]\n    }\n\n    // Close frames that are open at the end of the trace\n    for (let i = prevStack.length - 1; i >= 0; i--) {\n      closeFrame(prevStack[i], value)\n    }\n  }\n\n  forEachFrame(fn: (frame: Frame) => void) {\n    this.frames.forEach(fn)\n  }\n\n  getProfileWithRecursionFlattened(): Profile {\n    const builder = new CallTreeProfileBuilder()\n\n    const stack: (CallTreeNode | null)[] = []\n    const framesInStack = new Set<Frame>()\n\n    function openFrame(node: CallTreeNode, value: number) {\n      if (framesInStack.has(node.frame)) {\n        stack.push(null)\n      } else {\n        framesInStack.add(node.frame)\n        stack.push(node)\n        builder.enterFrame(node.frame, value)\n      }\n    }\n    function closeFrame(node: CallTreeNode, value: number) {\n      const stackTop = stack.pop()\n      if (stackTop) {\n        framesInStack.delete(stackTop.frame)\n        builder.leaveFrame(stackTop.frame, value)\n      }\n    }\n\n    this.forEachCall(openFrame, closeFrame)\n\n    const flattenedProfile = builder.build()\n    flattenedProfile.name = this.name\n    flattenedProfile.valueFormatter = this.valueFormatter\n\n    // When constructing a profile with recursion flattened,\n    // counter-intuitive things can happen to \"self time\" measurements\n    // for functions.\n    // For example, given the following list of stacks w/ weights:\n    //\n    // a 1\n    // a;b;a 1\n    // a;b;a;b;a 1\n    // a;b;a 1\n    //\n    // The resulting profile with recursion flattened out will look like this:\n    //\n    // a 1\n    // a;b 3\n    //\n    // Which is useful to view, but it's counter-intuitive to move self-time\n    // for frames around, since analyzing the self-time of functions is an important\n    // thing to be able to do accurately, and we don't want this to change when recursion\n    // is flattened. To work around that, we'll just copy the weights directly from the\n    // un-flattened profile.\n    this.forEachFrame(f => {\n      flattenedProfile.frames.getOrInsert(f).overwriteWeightWith(f)\n    })\n\n    return flattenedProfile\n  }\n\n  getInvertedProfileForCallersOf(focalFrameInfo: FrameInfo): Profile {\n    const focalFrame = Frame.getOrInsert(this.frames, focalFrameInfo)\n    const builder = new StackListProfileBuilder()\n\n    // TODO(jlfwong): Could construct this at profile\n    // construction time rather than on demand.\n    const nodes: CallTreeNode[] = []\n\n    function visit(node: CallTreeNode) {\n      if (node.frame === focalFrame) {\n        nodes.push(node)\n      } else {\n        for (let child of node.children) {\n          visit(child)\n        }\n      }\n    }\n\n    visit(this.appendOrderCalltreeRoot)\n\n    for (let node of nodes) {\n      const stack: FrameInfo[] = []\n      for (let n: CallTreeNode | null = node; n != null && n.frame !== Frame.root; n = n.parent) {\n        stack.push(n.frame)\n      }\n      builder.appendSampleWithWeight(stack, node.getTotalWeight())\n    }\n\n    const ret = builder.build()\n    ret.name = this.name\n    ret.valueFormatter = this.valueFormatter\n    return ret\n  }\n\n  getProfileForCalleesOf(focalFrameInfo: FrameInfo): Profile {\n    const focalFrame = Frame.getOrInsert(this.frames, focalFrameInfo)\n    const builder = new StackListProfileBuilder()\n\n    function recordSubtree(focalFrameNode: CallTreeNode) {\n      const stack: FrameInfo[] = []\n\n      function visit(node: CallTreeNode) {\n        stack.push(node.frame)\n        builder.appendSampleWithWeight(stack, node.getSelfWeight())\n        for (let child of node.children) {\n          visit(child)\n        }\n        stack.pop()\n      }\n\n      visit(focalFrameNode)\n    }\n\n    function findCalls(node: CallTreeNode) {\n      if (node.frame === focalFrame) {\n        recordSubtree(node)\n      } else {\n        for (let child of node.children) {\n          findCalls(child)\n        }\n      }\n    }\n\n    findCalls(this.appendOrderCalltreeRoot)\n\n    const ret = builder.build()\n    ret.name = this.name\n    ret.valueFormatter = this.valueFormatter\n    return ret\n  }\n\n  // Demangle symbols for readability\n  async demangle() {\n    let demangle: ((name: string) => string) | null = null\n\n    for (let frame of this.frames) {\n      // This function converts a mangled C++ and Rust name into a human-readable symbol.\n      if (\n        frame.name.startsWith('__Z') ||\n        frame.name.startsWith('_R') ||\n        frame.name.startsWith('_Z')\n      ) {\n        if (!demangle) {\n          const demangleModule = await import('./demangle')\n          demangle = await demangleModule.loadDemangling()\n        }\n        frame.name = demangle(frame.name)\n      }\n    }\n  }\n\n  remapSymbols(callback: SymbolRemapper) {\n    for (let frame of this.frames) {\n      const remapped = callback(frame)\n      if (remapped == null) {\n        continue\n      }\n      const {name, file, line, col} = remapped\n      if (name != null) {\n        frame.name = name\n      }\n      if (file != null) {\n        frame.file = file\n      }\n      if (line != null) {\n        frame.line = line\n      }\n      if (col != null) {\n        frame.col = col\n      }\n    }\n  }\n}\n\nexport class StackListProfileBuilder extends Profile {\n  _appendSample(stack: Frame[], weight: number, useAppendOrder: boolean) {\n    if (isNaN(weight)) throw new Error('invalid weight')\n    let node = useAppendOrder ? this.appendOrderCalltreeRoot : this.groupedCalltreeRoot\n\n    let framesInStack = new Set<Frame>()\n\n    for (let frame of stack) {\n      const last = useAppendOrder\n        ? lastOf(node.children)\n        : node.children.find(c => c.frame === frame)\n      if (last && !last.isFrozen() && last.frame == frame) {\n        node = last\n      } else {\n        const parent = node\n        node = new CallTreeNode(frame, node)\n        parent.children.push(node)\n      }\n      node.addToTotalWeight(weight)\n\n      // It's possible for the same frame to occur multiple\n      // times in the same call stack due to either direct\n      // or indirect recursion. We want to avoid counting that\n      // frame multiple times for a single sample, we so just\n      // track all of the unique frames that participated in\n      // this call stack, then add to their weight at the end.\n      framesInStack.add(node.frame)\n    }\n    node.addToSelfWeight(weight)\n\n    if (useAppendOrder) {\n      for (let child of node.children) {\n        child.freeze()\n      }\n    }\n\n    if (useAppendOrder) {\n      node.frame.addToSelfWeight(weight)\n\n      for (let frame of framesInStack) {\n        frame.addToTotalWeight(weight)\n      }\n\n      if (node === lastOf(this.samples)) {\n        this.weights[this.weights.length - 1] += weight\n      } else {\n        this.samples.push(node)\n        this.weights.push(weight)\n      }\n    }\n  }\n\n  appendSampleWithWeight(stack: FrameInfo[], weight: number) {\n    if (weight === 0) {\n      // Samples with zero weight have no effect, so let's ignore them\n      return\n    }\n    if (weight < 0) {\n      throw new Error('Samples must have positive weights')\n    }\n\n    const frames = stack.map(fr => Frame.getOrInsert(this.frames, fr))\n    this._appendSample(frames, weight, true)\n    this._appendSample(frames, weight, false)\n  }\n\n  private pendingSample: {\n    stack: FrameInfo[]\n    startTimestamp: number\n    centralTimestamp: number\n  } | null = null\n  appendSampleWithTimestamp(stack: FrameInfo[], timestamp: number) {\n    if (this.pendingSample) {\n      if (timestamp < this.pendingSample.centralTimestamp) {\n        throw new Error('Timestamps received out of order')\n      }\n      const endTimestamp = (timestamp + this.pendingSample.centralTimestamp) / 2\n      this.appendSampleWithWeight(\n        this.pendingSample.stack,\n        endTimestamp - this.pendingSample.startTimestamp,\n      )\n      this.pendingSample = {stack, startTimestamp: endTimestamp, centralTimestamp: timestamp}\n    } else {\n      this.pendingSample = {stack, startTimestamp: timestamp, centralTimestamp: timestamp}\n    }\n  }\n\n  build(): Profile {\n    if (this.pendingSample) {\n      if (this.samples.length > 0) {\n        this.appendSampleWithWeight(\n          this.pendingSample.stack,\n          this.pendingSample.centralTimestamp - this.pendingSample.startTimestamp,\n        )\n      } else {\n        // There is only a single sample. In this case, units will be meaningless,\n        // so we'll append with a weight of 1 and also clear any value formatter\n        this.appendSampleWithWeight(this.pendingSample.stack, 1)\n        this.setValueFormatter(new RawValueFormatter())\n      }\n    }\n    this.totalWeight = Math.max(\n      this.totalWeight,\n      this.weights.reduce((a, b) => a + b, 0),\n    )\n    this.sortGroupedCallTree()\n    return this\n  }\n}\n\n// As an alternative API for importing profiles more efficiently, provide a\n// way to open & close frames directly without needing to construct tons of\n// arrays as intermediaries.\nexport class CallTreeProfileBuilder extends Profile {\n  private appendOrderStack: CallTreeNode[] = [this.appendOrderCalltreeRoot]\n  private groupedOrderStack: CallTreeNode[] = [this.groupedCalltreeRoot]\n  private framesInStack = new Map<Frame, number>()\n  private stack: Frame[] = []\n\n  private lastValue: number = 0\n  private addWeightsToFrames(value: number) {\n    const delta = value - this.lastValue\n    for (let frame of this.framesInStack.keys()) {\n      frame.addToTotalWeight(delta)\n    }\n    const stackTop = lastOf(this.stack)\n    if (stackTop) {\n      stackTop.addToSelfWeight(delta)\n    }\n  }\n  private addWeightsToNodes(value: number, stack: CallTreeNode[]) {\n    const delta = value - this.lastValue\n    for (let node of stack) {\n      node.addToTotalWeight(delta)\n    }\n    const stackTop = lastOf(stack)\n    if (stackTop) {\n      stackTop.addToSelfWeight(delta)\n    }\n  }\n\n  private _enterFrame(frame: Frame, value: number, useAppendOrder: boolean) {\n    let stack = useAppendOrder ? this.appendOrderStack : this.groupedOrderStack\n    this.addWeightsToNodes(value, stack)\n\n    let prevTop = lastOf(stack)\n\n    if (prevTop) {\n      if (useAppendOrder) {\n        const delta = value - this.lastValue\n        if (delta > 0) {\n          this.samples.push(prevTop)\n          this.weights.push(value - this.lastValue)\n        } else if (delta < 0) {\n          throw new Error(\n            `Samples must be provided in increasing order of cumulative value. Last sample was ${this.lastValue}, this sample was ${value}`,\n          )\n        }\n      }\n\n      const last = useAppendOrder\n        ? lastOf(prevTop.children)\n        : prevTop.children.find(c => c.frame === frame)\n      let node: CallTreeNode\n      if (last && !last.isFrozen() && last.frame == frame) {\n        node = last\n      } else {\n        node = new CallTreeNode(frame, prevTop)\n        prevTop.children.push(node)\n      }\n      stack.push(node)\n    }\n  }\n  enterFrame(frameInfo: FrameInfo, value: number) {\n    const frame = Frame.getOrInsert(this.frames, frameInfo)\n    this.addWeightsToFrames(value)\n    this._enterFrame(frame, value, true)\n    this._enterFrame(frame, value, false)\n\n    this.stack.push(frame)\n    const frameCount = this.framesInStack.get(frame) || 0\n    this.framesInStack.set(frame, frameCount + 1)\n    this.lastValue = value\n    this.totalWeight = Math.max(this.totalWeight, this.lastValue)\n  }\n\n  private _leaveFrame(frame: Frame, value: number, useAppendOrder: boolean) {\n    let stack = useAppendOrder ? this.appendOrderStack : this.groupedOrderStack\n    this.addWeightsToNodes(value, stack)\n\n    if (useAppendOrder) {\n      const leavingStackTop = this.appendOrderStack.pop()\n      if (leavingStackTop == null) {\n        throw new Error(`Trying to leave ${frame.key} when stack is empty`)\n      }\n      if (this.lastValue == null) {\n        throw new Error(`Trying to leave a ${frame.key} before any have been entered`)\n      }\n      leavingStackTop.freeze()\n\n      if (leavingStackTop.frame.key !== frame.key) {\n        throw new Error(\n          `Tried to leave frame \"${frame.name}\" while frame \"${leavingStackTop.frame.name}\" was at the top at ${value}`,\n        )\n      }\n\n      const delta = value - this.lastValue\n      if (delta > 0) {\n        this.samples.push(leavingStackTop)\n        this.weights.push(value - this.lastValue)\n      } else if (delta < 0) {\n        throw new Error(\n          `Samples must be provided in increasing order of cumulative value. Last sample was ${this\n            .lastValue!}, this sample was ${value}`,\n        )\n      }\n    } else {\n      this.groupedOrderStack.pop()\n    }\n  }\n\n  leaveFrame(frameInfo: FrameInfo, value: number) {\n    const frame = Frame.getOrInsert(this.frames, frameInfo)\n    this.addWeightsToFrames(value)\n\n    this._leaveFrame(frame, value, true)\n    this._leaveFrame(frame, value, false)\n\n    this.stack.pop()\n    const frameCount = this.framesInStack.get(frame)\n    if (frameCount == null) return\n    if (frameCount === 1) {\n      this.framesInStack.delete(frame)\n    } else {\n      this.framesInStack.set(frame, frameCount - 1)\n    }\n    this.lastValue = value\n\n    this.totalWeight = Math.max(this.totalWeight, this.lastValue)\n  }\n\n  build(): Profile {\n    // Each stack is expected to contain a single node which we initialize to be\n    // the root node.\n    if (this.appendOrderStack.length > 1 || this.groupedOrderStack.length > 1) {\n      throw new Error('Tried to complete profile construction with a non-empty stack')\n    }\n    this.sortGroupedCallTree()\n    return this\n  }\n}\n", "// This file contains types which specify the speedscope file format.\n\nexport namespace FileFormat {\n  export type Profile = EventedProfile | SampledProfile\n\n  export interface File {\n    $schema: 'https://www.speedscope.app/file-format-schema.json'\n\n    // Data shared between profiles\n    shared: {\n      frames: Frame[]\n    }\n\n    // List of profile definitions\n    profiles: Profile[]\n\n    // The name of the contained profile group. If omitted, will use the name of\n    // the file itself.\n    // Added in 0.6.0\n    name?: string\n\n    // The index into the `profiles` array that should be displayed upon file\n    // load. If omitted, will default to displaying the first profile in the\n    // file.\n    //\n    // Added in 0.6.0\n    activeProfileIndex?: number\n\n    // The name of the the program which exported this profile. This isn't\n    // consumed but can be helpful for debugging generated data by seeing what\n    // was generating it! Recommended format is \"name@version\". e.g. when the\n    // file was exported by speedscope v0.6.0 itself, it will be\n    // \"speedscope@0.6.0\"\n    //\n    // Added in 0.6.0\n    exporter?: string\n  }\n\n  export interface Frame {\n    name: string\n    file?: string\n    line?: number\n    col?: number\n  }\n\n  export enum ProfileType {\n    EVENTED = 'evented',\n    SAMPLED = 'sampled',\n  }\n\n  export interface IProfile {\n    // Type of profile. This will future proof the file format to allow many\n    // different kinds of profiles to be contained and each type to be part of\n    // a discriminated union.\n    type: ProfileType\n  }\n\n  export interface EventedProfile extends IProfile {\n    type: ProfileType.EVENTED\n\n    // Name of the profile. Typically a filename for the source of the profile.\n    name: string\n\n    // Unit which all value are specified using in the profile.\n    unit: ValueUnit\n\n    // The starting value of the profile. This will typically be a timestamp.\n    // All event values will be displayed relative to this startValue.\n    startValue: number\n\n    // The final value of the profile. This will typically be a timestamp. This\n    // must be greater than or equal to the startValue. This is useful in\n    // situations where the recorded profile extends past the end of the recorded\n    // events, which may happen if nothing was happening at the end of the\n    // profile.\n    endValue: number\n\n    // List of events that occured as part of this profile.\n    // The \"at\" field of every event must be in non-decreasing order.\n    events: (OpenFrameEvent | CloseFrameEvent)[]\n  }\n\n  // List of indices into the frame array\n  type SampledStack = number[]\n\n  export interface SampledProfile extends IProfile {\n    type: ProfileType.SAMPLED\n\n    // Name of the profile. Typically a filename for the source of the profile.\n    name: string\n\n    // Unit which all value are specified using in the profile.\n    unit: ValueUnit\n\n    // The starting value of the profile. This will typically be a timestamp.\n    // All event values will be displayed relative to this startValue.\n    startValue: number\n\n    // The final value of the profile. This will typically be a timestamp. This\n    // must be greater than or equal to the startValue. This is useful in\n    // situations where the recorded profile extends past the end of the recorded\n    // events, which may happen if nothing was happening at the end of the\n    // profile.\n    endValue: number\n\n    // List of stacks\n    samples: SampledStack[]\n\n    // The weight of the sample at the given index. Should have\n    // the same length as the samples array.\n    weights: number[]\n  }\n\n  export type ValueUnit =\n    | 'none'\n    | 'nanoseconds'\n    | 'microseconds'\n    | 'milliseconds'\n    | 'seconds'\n    | 'bytes'\n\n  export enum EventType {\n    OPEN_FRAME = 'O',\n    CLOSE_FRAME = 'C',\n  }\n\n  interface IEvent {\n    type: EventType\n    at: number\n  }\n\n  // Indicates a stack frame opened. Every opened stack frame must have a\n  // corresponding close frame event, and the ordering must be balanced.\n  interface OpenFrameEvent extends IEvent {\n    type: EventType.OPEN_FRAME\n    // An index into the frames array in the shared data within the profile\n    frame: number\n  }\n\n  interface CloseFrameEvent extends IEvent {\n    type: EventType.CLOSE_FRAME\n    // An index into the frames array in the shared data within the profile\n    frame: number\n  }\n}\n", "import {\n  Profile,\n  CallTreeNode,\n  Frame,\n  CallTreeProfileBuilder,\n  FrameInfo,\n  StackListProfileBuilder,\n  ProfileGroup,\n} from './profile'\nimport {TimeFormatter, ByteFormatter, RawValueFormatter} from './value-formatters'\nimport {FileFormat} from './file-format-spec'\n\nexport function exportProfileGroup(profileGroup: ProfileGroup): FileFormat.File {\n  const frames: FileFormat.Frame[] = []\n\n  const indexForFrame = new Map<Frame, number>()\n  function getIndexForFrame(frame: Frame): number {\n    let index = indexForFrame.get(frame)\n    if (index == null) {\n      const serializedFrame: FileFormat.Frame = {\n        name: frame.name,\n      }\n      if (frame.file != null) serializedFrame.file = frame.file\n      if (frame.line != null) serializedFrame.line = frame.line\n      if (frame.col != null) serializedFrame.col = frame.col\n      index = frames.length\n      indexForFrame.set(frame, index)\n      frames.push(serializedFrame)\n    }\n    return index\n  }\n\n  const file: FileFormat.File = {\n    exporter: `speedscope@${require('../../package.json').version}`,\n    name: profileGroup.name,\n    activeProfileIndex: profileGroup.indexToView,\n    $schema: 'https://www.speedscope.app/file-format-schema.json',\n    shared: {frames},\n    profiles: [],\n  }\n\n  for (let profile of profileGroup.profiles) {\n    file.profiles.push(exportProfile(profile, getIndexForFrame))\n  }\n\n  return file\n}\n\nfunction exportProfile(profile: Profile, getIndexForFrame: (frame: Frame) => number) {\n  const eventedProfile: FileFormat.EventedProfile = {\n    type: FileFormat.ProfileType.EVENTED,\n    name: profile.getName(),\n    unit: profile.getWeightUnit(),\n    startValue: 0,\n    endValue: profile.getTotalWeight(),\n    events: [],\n  }\n  const openFrame = (node: CallTreeNode, value: number) => {\n    eventedProfile.events.push({\n      type: FileFormat.EventType.OPEN_FRAME,\n      frame: getIndexForFrame(node.frame),\n      at: value,\n    })\n  }\n  const closeFrame = (node: CallTreeNode, value: number) => {\n    eventedProfile.events.push({\n      type: FileFormat.EventType.CLOSE_FRAME,\n      frame: getIndexForFrame(node.frame),\n      at: value,\n    })\n  }\n  profile.forEachCall(openFrame, closeFrame)\n  return eventedProfile\n}\n\nfunction importSpeedscopeProfile(\n  serialized: FileFormat.Profile,\n  frames: FileFormat.Frame[],\n): Profile {\n  function setCommonProperties(p: Profile) {\n    const {name, unit} = serialized\n\n    switch (unit) {\n      case 'nanoseconds':\n      case 'microseconds':\n      case 'milliseconds':\n      case 'seconds':\n        p.setValueFormatter(new TimeFormatter(unit))\n        break\n\n      case 'bytes':\n        p.setValueFormatter(new ByteFormatter())\n        break\n\n      case 'none':\n        p.setValueFormatter(new RawValueFormatter())\n        break\n    }\n    p.setName(name)\n  }\n\n  function importEventedProfile(evented: FileFormat.EventedProfile) {\n    const {startValue, endValue, events} = evented\n\n    const profile = new CallTreeProfileBuilder(endValue - startValue)\n    setCommonProperties(profile)\n\n    const frameInfos: FrameInfo[] = frames.map((frame, i) => ({key: i, ...frame}))\n\n    for (let ev of events) {\n      switch (ev.type) {\n        case FileFormat.EventType.OPEN_FRAME: {\n          profile.enterFrame(frameInfos[ev.frame], ev.at - startValue)\n          break\n        }\n        case FileFormat.EventType.CLOSE_FRAME: {\n          profile.leaveFrame(frameInfos[ev.frame], ev.at - startValue)\n          break\n        }\n      }\n    }\n    return profile.build()\n  }\n\n  function importSampledProfile(sampled: FileFormat.SampledProfile) {\n    const {startValue, endValue, samples, weights} = sampled\n    const profile = new StackListProfileBuilder(endValue - startValue)\n    setCommonProperties(profile)\n\n    const frameInfos: FrameInfo[] = frames.map((frame, i) => ({key: i, ...frame}))\n\n    if (samples.length !== weights.length) {\n      throw new Error(\n        `Expected samples.length (${samples.length}) to equal weights.length (${weights.length})`,\n      )\n    }\n\n    for (let i = 0; i < samples.length; i++) {\n      const stack = samples[i]\n      const weight = weights[i]\n      profile.appendSampleWithWeight(\n        stack.map(n => frameInfos[n]),\n        weight,\n      )\n    }\n\n    return profile.build()\n  }\n\n  switch (serialized.type) {\n    case FileFormat.ProfileType.EVENTED:\n      return importEventedProfile(serialized)\n    case FileFormat.ProfileType.SAMPLED:\n      return importSampledProfile(serialized)\n  }\n}\n\nexport function importSpeedscopeProfiles(serialized: FileFormat.File): ProfileGroup {\n  return {\n    name: serialized.name || serialized.profiles[0].name || 'profile',\n    indexToView: serialized.activeProfileIndex || 0,\n    profiles: serialized.profiles.map(p => importSpeedscopeProfile(p, serialized.shared.frames)),\n  }\n}\n\nexport function saveToFile(profileGroup: ProfileGroup): void {\n  const file = exportProfileGroup(profileGroup)\n  const blob = new Blob([JSON.stringify(file)], {type: 'text/json'})\n\n  const nameWithoutExt = file.name ? file.name.split('.')[0]! : 'profile'\n  const filename = `${nameWithoutExt.replace(/\\W+/g, '_')}.speedscope.json`\n\n  console.log('Saving', filename)\n\n  const a = document.createElement('a')\n  a.download = filename\n  a.href = window.URL.createObjectURL(blob)\n  a.dataset.downloadurl = ['text/json', a.download, a.href].join(':')\n\n  // For this to work in Firefox, the <a> must be in the DOM\n  document.body.appendChild(a)\n  a.click()\n  document.body.removeChild(a)\n}\n"],
  "mappings": "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",
  "names": ["require_package", "__commonJSMin", "exports", "module", "lastOf", "ts", "sortBy", "key", "comparator", "a", "b", "keyA", "keyB", "getOrInsert", "map", "k", "fallback", "getOrElse", "getOrThrow", "KeyedSet", "t", "existing", "fn", "itMap", "it", "f", "itForEach", "zeroPad", "s", "width", "formatPercent", "percent", "formattedPercent", "fract", "x", "triangle", "findValueBisect", "lo", "hi", "f", "target", "targetRangeSize", "mid", "findIndexBisect", "ls", "noop", "args", "objectsHaveShallowEquality", "a", "b", "key", "memoizeByShallowEquality", "cb", "last", "result", "memoizeByReference", "lazyStatic", "base64lookupTable", "alphabet", "ret", "i", "decodeBase64", "encoded", "lookupTable", "quartetCount", "byteCount", "bytes", "offset", "enc1", "enc2", "enc3", "enc4", "sextet1", "sextet2", "sextet3", "sextet4", "RawValueFormatter", "v", "TimeFormatter", "unit", "s", "minutes", "seconds", "zeroPad", "ByteFormatter", "HasWeights", "delta", "other", "Frame", "_Frame", "info", "set", "CallTreeNode", "frame", "parent", "Profile", "_Profile", "totalWeight", "KeyedSet", "RawValueFormatter", "profile", "v", "f", "name", "n", "c", "visit", "node", "a", "b", "openFrame", "closeFrame", "start", "childTime", "child", "prevStack", "value", "sampleIndex", "stackTop", "lca", "lastOf", "toOpen", "i", "fn", "builder", "CallTreeProfileBuilder", "stack", "framesInStack", "flattenedProfile", "focalFrameInfo", "focalFrame", "StackListProfileBuilder", "nodes", "ret", "recordSubtree", "focalFrameNode", "findCalls", "demangle", "callback", "remapped", "file", "line", "col", "weight", "useAppendOrder", "last", "frames", "fr", "timestamp", "endTimestamp", "prevTop", "frameInfo", "frameCount", "leavingStackTop", "FileFormat", "ProfileType", "EventType", "exportProfileGroup", "profileGroup", "frames", "indexForFrame", "getIndexForFrame", "frame", "index", "serializedFrame", "file", "profile", "exportProfile", "eventedProfile", "FileFormat", "openFrame", "node", "value", "closeFrame", "importSpeedscopeProfile", "serialized", "setCommonProperties", "p", "name", "unit", "TimeFormatter", "ByteFormatter", "RawValueFormatter", "importEventedProfile", "evented", "startValue", "endValue", "events", "CallTreeProfileBuilder", "frameInfos", "i", "ev", "importSampledProfile", "sampled", "samples", "weights", "StackListProfileBuilder", "stack", "weight", "n", "importSpeedscopeProfiles", "saveToFile", "blob", "filename", "a"]
}
