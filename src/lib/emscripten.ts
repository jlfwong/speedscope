// Returns `input` with hex escapes expanded (e.g. `\20` becomes ` `.)
//

import {Frame, SymbolRemapper} from './profile'

// NOTE: This will fail to ignore escaped backslahes (e.g. `\\20`).
function unescapeHex(input: string): string {
  return input.replace(/\\([a-fA-F0-9]{2})/g, (_match, group) => {
    const scalar = parseInt(group, 16)
    return String.fromCharCode(scalar)
  })
}

// This imports symbol maps generated by emscripten using the "--emit-symbol-map" flag.
// It allows you to visualize a profile captured in a release build as long as you also
// have the associated symbol map. To do this, first drop the profile into speedscope
// and then drop the symbol map. After the second drop, the symbols will be remapped to
// their original names.
export function importEmscriptenSymbolMap(contents: string): SymbolRemapper | null {
  const lines = contents.split('\n')
  if (!lines.length) return null

  // Remove a trailing blank line if there is one
  if (lines[lines.length - 1] === '') lines.pop()
  if (!lines.length) return null

  const map = new Map<string, string>()
  const intRegex = /^(\d+):(.+)$/
  const idRegex = /^([\$\w]+):([\$\w-]+)$/

  for (const line of lines) {
    // Match lines like "103:__ZN8tinyxml210XMLCommentD0Ev"
    const intMatch = intRegex.exec(line)
    if (intMatch) {
      map.set(`wasm-function[${intMatch[1]}]`, unescapeHex(intMatch[2]))
      continue
    }

    // Match lines like "u6:__ZN8tinyxml210XMLCommentD0Ev"
    const idMatch = idRegex.exec(line)
    if (idMatch) {
      map.set(idMatch[1], unescapeHex(idMatch[2]))
      continue
    }

    return null
  }

  return (frame: Frame) => {
    if (!map.has(frame.name)) {
      return null
    }

    return {name: map.get(frame.name)}
  }
}
